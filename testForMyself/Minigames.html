<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="CSS/stylesBikeparks.css"/>
        <title>Minigames</title>
        <meta charset="UTF-8">
    <style>
        #game-container {
            margin-top:50px;
            margin-left:350px;
            width: 800px;
            height: 500px;
            position: relative;
            border: 1px solid black;
        }

        #player {
            width: 20px;
            height: 20px;
            position: absolute;
            background-color: red;
        }

        .projectile {
            width: 10px;
            height: 10px;
            position: absolute;
            background-color: blue;
        }
    </style>
</head>
<body>
    <div id="navbar">
        <a href="website.html" class="button">Home</a>
        <a href="#bikeparks" class="active">Bikeparks</a>
        <a href="Minigames.html" class="button">Minigames</a>
    </div>

    <div id="game-container">
        <div id="player"></div>
    </div>

    <script>
        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 500;
        const PLAYER_WIDTH = 20;
        const PLAYER_HEIGHT = 20;
        const PROJECTILE_WIDTH = 10;
        const PROJECTILE_HEIGHT = 10;
        const PROJECTILE_SPEED = 2;
        const SPAWN_INTERVAL = 1000;

        // Game state
        let playerX = (GAME_WIDTH - PLAYER_WIDTH) / 2;
        let playerY = (GAME_HEIGHT - PLAYER_HEIGHT) / 2;
        let projectiles = [];

        // DOM elements
        const gameContainer = document.getElementById('game-container');
        const player = document.getElementById('player');

        // Update player position
        function updatePlayerPosition(x, y) {
            player.style.left = x + 'px';
            player.style.top = y + 'px';
        }

        // Move projectiles and check for collisions
        function updateProjectiles() {
            projectiles.forEach((projectile, index) => {
                const projectileTop = parseInt(projectile.style.top);
                const projectileLeft = parseInt(projectile.style.left);

                // Check for collision with player
                if (
                    projectileTop < playerY + PLAYER_HEIGHT &&
                    projectileTop + PROJECTILE_HEIGHT > playerY &&
                    projectileLeft < playerX + PLAYER_WIDTH &&
                    projectileLeft + PROJECTILE_WIDTH > playerX
                ) {
                    alert('Verloren! Nochmal?');
                    resetGame();
                    return;
                }

                // Move projectile
                projectile.style.top = projectileTop + PROJECTILE_SPEED + 'px';

                // Remove projectile if it goes off-screen
                if (projectileTop > GAME_HEIGHT) {
                    projectiles.splice(index, 1);
                    gameContainer.removeChild(projectile);
                }
            });
        }

        // Spawn new projectile
        function spawnProjectile() {
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.style.left = Math.random() * (GAME_WIDTH - PROJECTILE_WIDTH) + 'px';
            projectile.style.top = '-10px';

            projectiles.push(projectile);
            gameContainer.appendChild(projectile);
        }

        // Reset the game
        function resetGame() {
            projectiles.forEach(projectile => gameContainer.removeChild(projectile));
            projectiles = [];
            updatePlayerPosition((GAME_WIDTH - PLAYER_WIDTH) / 2, (GAME_HEIGHT - PLAYER_HEIGHT) / 2);
        }

        // Keyboard controls
        window.addEventListener('keydown', (event) => {
            const step = 10;
            switch (event.key) {
                case 'ArrowUp':
                    playerY = Math.max(playerY - step, 0);
                    updatePlayerPosition(playerX, playerY);
                    break;
                case 'ArrowDown':
                    playerY = Math.min(playerY + step, GAME_HEIGHT - PLAYER_HEIGHT);
                    updatePlayerPosition(playerX, playerY);
                    break;
                case 'ArrowLeft':
                    playerX = Math.max(playerX - step, 0);
                    updatePlayerPosition(playerX, playerY);
                    break;
                case 'ArrowRight':
                    playerX = Math.min(playerX + step, GAME_WIDTH - PLAYER_WIDTH);
                    updatePlayerPosition(playerX, playerY);
                    break;
            }
        });

        // Game loop
        setInterval(() => {
            updateProjectiles();
        }, 10);

        // Projectile spawning loop
        setInterval(() => {
            spawnProjectile();
        }, SPAWN_INTERVAL);
    </script>
</body>
</html>
